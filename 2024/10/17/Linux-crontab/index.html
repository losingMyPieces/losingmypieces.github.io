<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux crontab | zero</title><meta name="author" content="zyming"><meta name="copyright" content="zyming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="​crontab​ 是一个用于管理用户的定时任务调度工具。它允许用户设置在特定时间自动运行的命令或脚本，常用于定期执行备份、系统监控、数据处理等任务。 atd – 执行一次性命令的守护进程生活中，我们有太多场景需要使用到闹钟，比如早上 7 点起床，下午 4 点开会，晚上 8 点购物，等等。 在 Linux 系统里，我们同样也有类似的需求。比如我们想在凌晨 1 点将文件上传服务器，或者在晚上 10">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux crontab">
<meta property="og:url" content="http://example.com/2024/10/17/Linux-crontab/index.html">
<meta property="og:site_name" content="zero">
<meta property="og:description" content="​crontab​ 是一个用于管理用户的定时任务调度工具。它允许用户设置在特定时间自动运行的命令或脚本，常用于定期执行备份、系统监控、数据处理等任务。 atd – 执行一次性命令的守护进程生活中，我们有太多场景需要使用到闹钟，比如早上 7 点起床，下午 4 点开会，晚上 8 点购物，等等。 在 Linux 系统里，我们同样也有类似的需求。比如我们想在凌晨 1 点将文件上传服务器，或者在晚上 10">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/10/17/Linux-crontab/image-20240929101230-geczmu2.png">
<meta property="article:published_time" content="2024-10-17T02:46:25.000Z">
<meta property="article:modified_time" content="2024-10-17T06:37:07.766Z">
<meta property="article:author" content="zyming">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/17/Linux-crontab/image-20240929101230-geczmu2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux crontab",
  "url": "http://example.com/2024/10/17/Linux-crontab/",
  "image": "",
  "datePublished": "2024-10-17T02:46:25.000Z",
  "dateModified": "2024-10-17T06:37:07.766Z",
  "author": [
    {
      "@type": "Person",
      "name": "zyming",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2024/10/17/Linux-crontab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux crontab',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/LuoyuStanding_2560x1440.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">zero</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux crontab</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux crontab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-17T02:46:25.000Z" title="发表于 2024-10-17 10:46:25">2024-10-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T06:37:07.766Z" title="更新于 2024-10-17 14:37:07">2024-10-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>​<code>crontab</code>​ 是一个用于管理用户的定时任务调度工具。它允许用户设置在特定时间自动运行的命令或脚本，常用于定期执行备份、系统监控、数据处理等任务。</p>
<h1 id="atd-–-执行一次性命令的守护进程"><a href="#atd-–-执行一次性命令的守护进程" class="headerlink" title="atd – 执行一次性命令的守护进程"></a>atd – 执行一次性命令的守护进程</h1><p>生活中，我们有太多场景需要使用到闹钟，比如早上 7 点起床，下午 4 点开会，晚上 8 点购物，等等。</p>
<p>在 Linux 系统里，我们同样也有类似的需求。比如我们想在凌晨 1 点将文件上传服务器，或者在晚上 10 点确认系统状态，等等。</p>
<p>但我们不可能一直守在电脑前，毕竟我们也需要下班&#x2F;睡觉，还要陪对象（new一个也行）。而且即使在上班期间，如果到点了还需要人工操作，未免效率太低了。</p>
<p>​<code>at</code>​ 命令就是为这个需求而诞生的。使用 <code>at</code>​ 命令，你可以在特定时间自动完成你所设定的任务，也可以实现自动化，非常方便快捷！</p>
<h2 id="at安装"><a href="#at安装" class="headerlink" title="at安装"></a>at安装</h2><p>一般来讲，大部分 Linux 发行版都已经安装了 <code>at</code>​ 命令，不确定的话可以使用 <code>at -V</code>​ 命令查看，如果有版本返回，说明就可以正常使用 <code>at</code>​ 命令。</p>
<p>at -V # 查看版本</p>
<h2 id="atd服务启动"><a href="#atd服务启动" class="headerlink" title="atd服务启动"></a>atd服务启动</h2><p>你可以使用 <code>systemctl</code>​ 命令启用 <code>atd</code>​ 服务并将它们设置为从现在开始自动启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now atd</span><br></pre></td></tr></table></figure>

<h2 id="at命令基本用法"><a href="#at命令基本用法" class="headerlink" title="at命令基本用法"></a>at命令基本用法</h2><ul>
<li><p>语法</p>
<p>at [options] [time]</p>
</li>
<li><p>选项</p>
<p>-f 指定包含具体指令的任务文件</p>
<p>-q 指定新任务的队列名称</p>
<p>-l 显示待执行任务的列表</p>
<p>-d 删除待执行的任务</p>
<p>-m 任务执行完后向用户发送邮件</p>
</li>
<li><p>time：时间格式</p>
<p>HH:MM</p>
<p>HH:MM YYYY-MM-DD 或者 HH:MM MM&#x2F;DD&#x2F;YYYY</p>
<p>HH:MM[am|pm] [month] [date]</p>
<p>HH:MM[am|pm] + number [ minutes | hours | days | weeks | months | years ]</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li>echo “echo ‘hello’ &gt;&gt; &#x2F;home&#x2F;zyming&#x2F;at-test.txt” | at 3:30 am 10&#x2F;01&#x2F;2024 或者 echo “echo ‘hello’ &gt;&gt; &#x2F;home&#x2F;zyming&#x2F;at-test.txt” | at 3:30 am 2024-10-01</li>
</ol>
<h2 id="使用-at-命令交互性安排任务"><a href="#使用-at-命令交互性安排任务" class="headerlink" title="使用 at 命令交互性安排任务"></a>使用 at 命令交互性安排任务</h2><p>at 11:00 am</p>
<blockquote>
<p>echo “hello” &gt;&gt; &#x2F;home&#x2F;zyming&#x2F;at-test.txt</p>
</blockquote>
<p>ctrl+d退出交互环境</p>
<h2 id="使用-at-命令安排任务"><a href="#使用-at-命令安排任务" class="headerlink" title="使用 at 命令安排任务"></a>使用 at 命令安排任务</h2><p>echo “echo ‘hello again’ &gt;&gt; &#x2F;home&#x2F;zyming&#x2F;at-test.txt” | at now + 1 minutes</p>
<h2 id="查看-at-任务队列"><a href="#查看-at-任务队列" class="headerlink" title="查看 at 任务队列"></a>查看 at 任务队列</h2><p>at -l &lt;&#x3D;&gt; atq</p>
<h3 id="从任务队列中删除任务"><a href="#从任务队列中删除任务" class="headerlink" title="从任务队列中删除任务"></a>从任务队列中删除任务</h3><p>atrm &lt;任务编号&gt;</p>
<h2 id="根据at任务列表选择删除的内容"><a href="#根据at任务列表选择删除的内容" class="headerlink" title="根据at任务列表选择删除的内容"></a>根据at任务列表选择删除的内容</h2><p>atq &amp;&amp; read -p “输入待查看at任务编号：” n &amp;&amp; atrm $n</p>
<h2 id="查看at任务内容"><a href="#查看at任务内容" class="headerlink" title="查看at任务内容"></a>查看at任务内容</h2><p>at -c &lt;任务编号&gt; | tail -n +71 | head -n -2</p>
<p>或者</p>
<h3 id="通过管理员权限查看-var-spool-at中保存的内容"><a href="#通过管理员权限查看-var-spool-at中保存的内容" class="headerlink" title="通过管理员权限查看 &#x2F;var&#x2F;spool&#x2F;at中保存的内容"></a>通过管理员权限查看 &#x2F;var&#x2F;spool&#x2F;at中保存的内容</h3><p>(sudo ls &#x2F;var&#x2F;spool&#x2F;at | awk ‘{print NR “：” 1}’) &amp;&amp; read -p “需要查看第几个at任务：” n &amp;&amp; sudo tail -n+71 &#x2F;var&#x2F;spool&#x2F;at&#x2F;(sudo ls &#x2F;var&#x2F;spool&#x2F;at | head -n $n | tail -n 1)| head -n -2</p>
<h2 id="根据at任务列表选择查看的内容"><a href="#根据at任务列表选择查看的内容" class="headerlink" title="根据at任务列表选择查看的内容"></a>根据at任务列表选择查看的内容</h2><p>atq &amp;&amp; read -p “输入待查看at任务编号：” n &amp;&amp;  (at -c $n | tail -n +71 | head -n -2)</p>
<h1 id="batch-–系统空闲时执行的后台任务"><a href="#batch-–系统空闲时执行的后台任务" class="headerlink" title="batch –系统空闲时执行的后台任务"></a>batch –系统空闲时执行的后台任务</h1><p>batch是利用at来进行指令下达的，它会在cpu的工作负载小于0.8时，马上执行用户下达的工作任务。</p>
<ol>
<li>uptime # 查看当前负载（load average）</li>
<li>bc -lq &lt;&lt;&lt; “scale&#x3D;100000; 4*a(1)” &amp;</li>
<li>bc -lq &lt;&lt;&lt; “scale&#x3D;100000; 4*a(1)” &amp; # 小于0.8，则继续增加负载</li>
<li>uptime # 查看当前负载（load average）</li>
<li>batch &gt; &#x2F;usr&#x2F;bin&#x2F;updatedb</li>
<li>date; atq # 查看此时是否执行（当前时间超过计划时间）</li>
<li>jobs &gt; kill -9 %?</li>
<li>uptime;atq # 查看执行与否</li>
</ol>
<h1 id="crond-–-执行周期性命令的守护进程"><a href="#crond-–-执行周期性命令的守护进程" class="headerlink" title="crond – 执行周期性命令的守护进程"></a>crond – 执行周期性命令的守护进程</h1><h2 id="crontab安装与检查"><a href="#crontab安装与检查" class="headerlink" title="crontab安装与检查"></a>crontab安装与检查</h2><p>sudo yum list crontabs # 检查是否安装</p>
<p>crontab -V # 查看版本</p>
<p>sudo yum install crontab</p>
<h2 id="crontab服务启动与关闭"><a href="#crontab服务启动与关闭" class="headerlink" title="crontab服务启动与关闭"></a>crontab服务启动与关闭</h2><p>systemctl start crond # 启动</p>
<p>systemctl stop crond # 关闭</p>
<p>systemctl enable crond # 开机自启</p>
<h2 id="全局配置文件（crontab每分钟检测一次-etc-crontab和-var-spool-cron）"><a href="#全局配置文件（crontab每分钟检测一次-etc-crontab和-var-spool-cron）" class="headerlink" title="全局配置文件（crontab每分钟检测一次&#x2F;etc&#x2F;crontab和&#x2F;var&#x2F;spool&#x2F;cron）"></a>全局配置文件（crontab每分钟检测一次&#x2F;etc&#x2F;crontab和&#x2F;var&#x2F;spool&#x2F;cron）</h2><p>cron.hourly # 是每个小时执行一次的job</p>
<p>cron.daily # 是每天执行一次的job</p>
<p>cron.monthly # 是每月执行一次的job</p>
<p>cron.d # 是系统自动定期需要做的任务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/cron.d/0hourly</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run the hourly jobs</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure>

<p>crontab # 是设定定时任务执行文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/crontab</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br></pre></td></tr></table></figure>

<p>crontab.deny # 文件用于控制不让哪些用户使用crontab</p>
<h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><p>每个用户都有自己的cron配置文件，通过crontab -e就可以编辑。</p>
<p><a target="_blank" rel="noopener" href="https://crontab.guru/">时间配置测试网站</a></p>
<p><img src="/2024/10/17/Linux-crontab/image-20240929101230-geczmu2.png" alt="image-geczmu2"></p>
<p>星号（）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如&#x2F;10，如果用在minute字段，表示每十分钟执行一次。</p>
<h2 id="定时任务实例"><a href="#定时任务实例" class="headerlink" title="定时任务实例"></a>定时任务实例</h2><ol>
<li><p>每月每天凌晨3点30分和中午12点30分执行test.sh脚本</p>
<p> 30 3,12 * * * &#x2F;home&#x2F;test.sh</p>
</li>
<li><p>每月每天每隔6小时的每30分钟执行test.sh脚本</p>
<p> &#x2F;30 &#x2F;6 * * * &#x2F;home&#x2F;test.sh</p>
</li>
<li><p>每月每天早上8点到下午18点每隔2小时的每30分钟执行test.sh脚本</p>
<p> &#x2F;30 8-18&#x2F;2 * * * &#x2F;home&#x2F;test.sh</p>
</li>
<li><p>每月每天晚上21点30分执行test.sh脚本</p>
<p> 30 21 * * * &#x2F;home&#x2F;test.sh</p>
</li>
<li><p>每月1号、10号、22号凌晨4点45分执行test.sh脚本</p>
<p> 45 4 1,10,22 * * &#x2F;home&#x2F;test.sh</p>
</li>
</ol>
<p><strong>注意</strong></p>
<p> 某些时候天和星期一起设置会冲突</p>
<h2 id="查询-删除当前用户定时任务"><a href="#查询-删除当前用户定时任务" class="headerlink" title="查询&#x2F;删除当前用户定时任务"></a>查询&#x2F;删除当前用户定时任务</h2><p>crontab -l &#x2F; crontab -r</p>
<h1 id="可唤醒停机期间的工作任务（anacron）"><a href="#可唤醒停机期间的工作任务（anacron）" class="headerlink" title="可唤醒停机期间的工作任务（anacron）"></a>可唤醒停机期间的工作任务（anacron）</h1><ol>
<li><p>目的</p>
<p> anacron不是crontab的替代物，它是一个程序，针对非24小时一直启动linux系统的crontab执行，以及由于特殊原因超过预计时间没被执行的定时任务而提出</p>
</li>
</ol>
<h2 id="anacron与-etc-anacrontab"><a href="#anacron与-etc-anacrontab" class="headerlink" title="anacron与&#x2F;etc&#x2F;anacrontab"></a>anacron与&#x2F;etc&#x2F;anacrontab</h2><p>anacron是一个程序，放到了&#x2F;etc&#x2F;cron.hourly，得以每个小时运行一次。</p>
<h2 id="anacrontab的执行流程（以cron-daily为例）"><a href="#anacrontab的执行流程（以cron-daily为例）" class="headerlink" title="anacrontab的执行流程（以cron.daily为例）"></a>anacrontab的执行流程（以cron.daily为例）</h2><ol>
<li>分析&#x2F;etc&#x2F;anacrontab，得到cron.dailly的执行周期为1天；</li>
<li>由&#x2F;var&#x2F;spool&#x2F;cron.daily得到上次执行anacrontab的时间戳；</li>
<li>若该时间戳与目前时间相差超过了1天，那么准备执行指令；</li>
<li>根据&#x2F;etc&#x2F;anacrontab中设定的delay in minutes和START_HOURS_RANGE&#x3D;3-22，得出指令的运行时间应当是在当天的3:00到22:00之间，每个小时的前五分钟内随机执行，若不在此时间范围以内，则在第二天的3:00开始执行；</li>
<li>执行完 run-parts &#x2F;etc&#x2F;cron.daily，anacrontab整个流程结束。</li>
</ol>
<p>总结：anacrontab每个小时去检测时间戳的差距，可以使得cron.daily中的任务每天执行一次，而由于其执行周期为1小时，因此开机后的1小时左右系统会进行一定的检测工作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">zyming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/17/Linux-crontab/">http://example.com/2024/10/17/Linux-crontab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">zero</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post-share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/16/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/2024/10/29/Linux-ug/" title="Linux账号和群组"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux账号和群组</div></div><div class="info-2"><div class="info-item-1">Linux系统登录需要用户名和密码，但是不同的用户拥有不同的权限。有一位特殊的存在：root—— 系统管理员，它在系统中拥有全部权限，可以管理用户的文件权限、目录权限等等。接下来就围绕账号与群组进行具体讨论。 Linux账号与群组UID和GID对于用户，记住Linux系统的用户名和密码足矣，然而对于Linux主机，则需要记住用户的UID（User ID）和密码。首先我们要有一个概念：Linux系统由文件组成，包括目录也是文件组成。 Linux规定所有的配置文件都保存在&#x2F;etc目录下，而每个用户名和UID的对应则保存在&#x2F;etc&#x2F;passwd文件中。以前用户的密码也保存在&#x2F;etc&#x2F;passwd文件中，但是目前用户的密码在&#x2F;etc&#x2F;shadow文件中密文保存。 每个用户都必须属于一个组，在未指定所属组的情况下，用户的组为自己本身。同样，组由于GID（Group...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/27/Linux-prompt/" title="个性化-命令提示符（Prompt）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">个性化-命令提示符（Prompt）</div></div><div class="info-2"><div class="info-item-1">bash是一个指挥操作系统的好工具，当你进入到这台系统的shell界面，发现各式各样的提示符会否使你头疼？由于linux系统太过自由，不管是root用户还是普通用户，都能对各自的提示符个性化设置，本文在此介绍对普通用户和全体用户的提示符个性化设置。 介绍　　在默认情况下，用户登录bash看到的提示符为： 12[root@主机名 ~]# 	#root用户[user@主机名 ~]$ 	#用户名为user  　　能看的出，针对不同的用户会出现不同的命令提示符，并且root用户的标识是#，普通用户的标识是$。 　　有了发现之后，我首先是去寻找当前用户下的配置文件（~&#x2F;.bashrc），结果没有任何发现，然后去寻找全局的配置文件（&#x2F;etc&#x2F;bashrc），里面存在对Prompt的设置变量 $PS1 1PS1=&quot;[\u@\h \W]\\$  　　bash会在被加载时读取它，并按照如下规则显示： 12345678910111213141516171819\e 控制符\033\u 当前用户\h 主机名简称\H 主机名\w 当前工作目录（全路径）\W...</div></div></div></a><a class="pagination-related" href="/2025/02/05/%E5%A6%82%E4%BD%95%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E7%A7%BB%E9%99%A4%E6%97%A7%E7%89%88%E6%9C%AC%EF%BC%88%E4%BB%A5RHEL%E4%B8%BA%E4%BE%8B%EF%BC%89/" title="如何日常更新内核并移除旧版本（以RHEL为例）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-05</div><div class="info-item-2">如何日常更新内核并移除旧版本（以RHEL为例）</div></div><div class="info-2"><div class="info-item-1">在红帽发行版本Linux系统RHEL中，更新后可能会保留多个内核版本。要删除不需要的内核版本，可以按照以下步骤操作： 查看查看已安装的内核版本1rpm -qa | grep kernel  　　或 1uname -r   　　​uname -r​ 显示当前正在使用的内核版本，不要删除它。 查看所有可用更新命令1sudo yum check-update  更新更新软件包和内核1sudo yum update  　　下载完成后根据提示，键入y同意安装。 只更新软件包1sudo yum -y upgrade  删除删除给定的内核版本　　例如，删除 kernel-4.18.0-553.33.1.el8_10.x86_64​： 1sudo yum remove kernel-4.18.0-553.33.1.el8_10.x86_64  自动删除内核（可选）　　设置只保留最近的两个内核版本： 1sudo sed -i &#x27;s/installonly_limit=[0-9]\+/installonly_limit=2/&#x27;...</div></div></div></a><a class="pagination-related" href="/2025/01/06/Linux-vim%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E4%BD%86cat%E6%AD%A3%E5%B8%B8/" title="Linux vim编辑文件中文乱码但cat正常"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-06</div><div class="info-item-2">Linux vim编辑文件中文乱码但cat正常</div></div><div class="info-2"><div class="info-item-1">问题分析　　 在Kylin麒麟V10操作系统上，用vim编辑文件，出现了中文乱码，但是cat查看文件正常显示的问题，个人感觉是编码问题，但是反应不够准确，比如，我认为临时添加上局部变量以支持中文语系即可。 12export lang=zh-CNexport lc_all=zh-CN  　　但是这样只能解决终端的显示问题，并且导入的语言包不对（正确为：zh_CN.utf8），应该通过以下的命令查看当前终端所支持的语言环境和字符集类型： 1234#查看系统的当前的语言类型设置locale#查看已安装的可用语言包locale -a  终端乱码设置　　对于某些终端机无法支持中文语系，我们设置以下utf8语言环境，以正确显示输出信息： 12export lang=en_US.UFT-8export LC_CTYPE=en_US.UFT-8  vim中文乱码设置　　进入正题，vim要正确显示中文，需要配置中文的语系： 123456#1.进入vim编辑模式vim /etc/vimrc#2.按G，按o编辑最后一行#3.加入以下语系中的一个set...</div></div></div></a><a class="pagination-related" href="/2024/12/11/Linux-shell-2/" title="Shell流程控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-11</div><div class="info-item-2">Shell流程控制</div></div><div class="info-2"><div class="info-item-1">if条件判断语句1234567if 表达式 ; then	语句1elif 表达式 ; then # 可以不要	语句2else # 可以不要	语句3fi  表达式可以用到的逻辑运算符：    选项 含义    -f 判断文件是否存在eg: if [ -f filename ]   -d 判断目录是否存在eg: if [ -d dir ]   -eq 等于 应用于：整型比较   -ne 不等于 应用于：整型比较   -lt 小于 应用于：整型比较   -gt 大于 应用于：整型比较   -le 小于或等于 应用于：整型比较   -ge 大于或等于 应用于：整型比较   -a and。 eg: [ 表达式 -a 表达式 ]   -o or。eg: [ 表达式 -o 表达式 ]   -z 空字符串   如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。 1234567891011121314a=10b=20if (( $a == $b ))then   echo &quot;a 等于 b&quot;elif (( $a &gt; $b ))then  ...</div></div></div></a><a class="pagination-related" href="/2024/12/09/Linux-shell-1/" title="Shell变量、运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">Shell变量、运算符</div></div><div class="info-2"><div class="info-item-1">Shell 是操作系统的最外层，为用户提供了一个与系统交互的界面，它不仅支持直接输入命令来控制进程和文件，还整合了编程语言的特性，使用户能够通过编写脚本实现复杂的任务。可以说，Shell 是用户与 Linux 操作系统之间的重要桥梁。 Linux 系统中的 Shell 种类非常丰富，常见的有 Bourne Shell（/usr/bin/sh​）、Bourne Again Shell（/usr/bin/bash​）、C Shell、Korn Shell（K Shell）等。由于不同的 Shell 拥有不同的语法特性，它们之间的脚本通常不能直接通用。然而，在众多选择中，最为流行且广泛使用的便是 Bash（Bourne Again Shell），它功能强大、兼容性好，几乎是所有现代 Linux 发行版的默认 Shell，后面shell默认为Bash。 接下来探讨 Shell 脚本的基本语法与核心功能，并通过实际案例展示如何利用 Bash...</div></div></div></a><a class="pagination-related" href="/2024/11/29/Linux-du/" title="du磁盘占用分析指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">du磁盘占用分析指令</div></div><div class="info-2"><div class="info-item-1">​​du​​(disk usage的缩写，磁盘使用情况)是一个标准Unix程序，用于估量文件或文件夹的磁盘使用情况。 默认情况下，du​显示当前目录每个文件与目录的被分配磁盘空间的情况。链接文件将会显示其本身大小而非其链接对象；目录则会显示其内容的大小。 用途 检查某个目录的大小：用来查看一个目录及其子目录占用的空间，以便做清理或备份。 找出占用大量磁盘空间的文件或目录：通过 du​ 命令，你可以定位磁盘占用较大的文件或子目录，以便做进一步操作。 查看文件系统使用情况：可以通过限制深度来快速查看文件系统中各个目录的占用情况。  用法du [options] [file|directory…] 定制化显示内容：123456789101112131415161718192021222324252627#-h（human-readable）：以人类可读的格式显示文件大小（例如 KB、MB、GB 等）。du -h /path/to/directory#-s（summarize）：只显示指定目录的总计大小，不显示子目录的大小。du -sh...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#atd-%E2%80%93-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">atd – 执行一次性命令的守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#at%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">at安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atd%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.</span> <span class="toc-text">atd服务启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#at%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">at命令基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-at-%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E6%80%A7%E5%AE%89%E6%8E%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">使用 at 命令交互性安排任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-at-%E5%91%BD%E4%BB%A4%E5%AE%89%E6%8E%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">使用 at 命令安排任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-at-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.6.</span> <span class="toc-text">查看 at 任务队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">从任务队列中删除任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEat%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.7.</span> <span class="toc-text">根据at任务列表选择删除的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bat%E4%BB%BB%E5%8A%A1%E5%86%85%E5%AE%B9"><span class="toc-number">1.8.</span> <span class="toc-text">查看at任务内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%9F%A5%E7%9C%8B-var-spool-at%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.8.1.</span> <span class="toc-text">通过管理员权限查看 &#x2F;var&#x2F;spool&#x2F;at中保存的内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEat%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E6%9F%A5%E7%9C%8B%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.9.</span> <span class="toc-text">根据at任务列表选择查看的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#batch-%E2%80%93%E7%B3%BB%E7%BB%9F%E7%A9%BA%E9%97%B2%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">batch –系统空闲时执行的后台任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crond-%E2%80%93-%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">crond – 执行周期性命令的守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#crontab%E5%AE%89%E8%A3%85%E4%B8%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">crontab安装与检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crontab%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">3.2.</span> <span class="toc-text">crontab服务启动与关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88crontab%E6%AF%8F%E5%88%86%E9%92%9F%E6%A3%80%E6%B5%8B%E4%B8%80%E6%AC%A1-etc-crontab%E5%92%8C-var-spool-cron%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">全局配置文件（crontab每分钟检测一次&#x2F;etc&#x2F;crontab和&#x2F;var&#x2F;spool&#x2F;cron）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">用户配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">定时任务实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.6.</span> <span class="toc-text">查询&#x2F;删除当前用户定时任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%94%A4%E9%86%92%E5%81%9C%E6%9C%BA%E6%9C%9F%E9%97%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%EF%BC%88anacron%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">可唤醒停机期间的工作任务（anacron）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#anacron%E4%B8%8E-etc-anacrontab"><span class="toc-number">4.1.</span> <span class="toc-text">anacron与&#x2F;etc&#x2F;anacrontab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#anacrontab%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5cron-daily%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">anacrontab的执行流程（以cron.daily为例）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/Linux-prompt/" title="个性化-命令提示符（Prompt）">个性化-命令提示符（Prompt）</a><time datetime="2025-04-27T07:52:14.000Z" title="发表于 2025-04-27 15:52:14">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/12/Leetcode-1st/" title="No.1 两数之和 (easy)">No.1 两数之和 (easy)</a><time datetime="2025-02-12T06:23:16.000Z" title="发表于 2025-02-12 14:23:16">2025-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/10/%E8%87%AA%E5%AE%9A%E4%B9%89github-pages%E5%9F%9F%E5%90%8D/" title="自定义github pages域名">自定义github pages域名</a><time datetime="2025-02-10T01:19:36.000Z" title="发表于 2025-02-10 09:19:36">2025-02-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/05/%E5%A6%82%E4%BD%95%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E7%A7%BB%E9%99%A4%E6%97%A7%E7%89%88%E6%9C%AC%EF%BC%88%E4%BB%A5RHEL%E4%B8%BA%E4%BE%8B%EF%BC%89/" title="如何日常更新内核并移除旧版本（以RHEL为例）">如何日常更新内核并移除旧版本（以RHEL为例）</a><time datetime="2025-02-05T07:09:23.000Z" title="发表于 2025-02-05 15:09:23">2025-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/%E6%96%B0%E5%A2%9E%E6%91%98%E5%BD%95%E5%8A%9F%E8%83%BD/" title="新增摘录功能">新增摘录功能</a><time datetime="2025-01-06T07:42:08.000Z" title="发表于 2025-01-06 15:42:08">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/LuoyuStanding_2560x1440.webp);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By zyming</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>